{"meta":{"title":"KyleSun的个人博客","subtitle":"","description":"","author":"KyleSun","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2023-10-12T08:33:35.000Z","updated":"2023-10-12T08:38:26.900Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"生活","date":"2023-10-12T08:34:50.000Z","updated":"2023-10-12T08:38:28.128Z","comments":true,"path":"live/index.html","permalink":"http://example.com/live/index.html","excerpt":"","text":""},{"title":"读书","date":"2023-10-12T08:35:12.000Z","updated":"2023-10-13T01:22:31.299Z","comments":true,"path":"read/index.html","permalink":"http://example.com/read/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-10-12T08:35:12.000Z","updated":"2023-10-12T08:38:14.899Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Vuex状态管理","slug":"10. Vuex状态管理","date":"2023-10-30T16:00:00.000Z","updated":"2023-10-31T06:01:12.451Z","comments":true,"path":"2023/10/31/10. Vuex状态管理/","link":"","permalink":"http://example.com/2023/10/31/10.%20Vuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/","excerpt":"","text":"1. 简介Vuex（Vue.js 状态管理模式）是一个用于Vue.js应用程序的状态管理库，它有助于管理应用程序中的数据和状态。通过Vuex，您可以将应用程序的状态集中存储在一个地方，并通过一些规则来更改它。这有助于使您的应用程序更容易维护，并且对于大型应用程序来说特别有用。 2. 基础教程1. 安装 Vuex 首先，确保您的Vue.js应用程序已经安装和配置。然后，使用npm或yarn安装Vuex： 1npm install vuex 2. 创建Vuex Store 在您的应用程序中创建一个Vuex store。通常，您会在一个名为store.js或index.js的文件中创建它。以下是一个示例： 123456789101112131415161718192021// store.jsimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state) &#123; state.count++ &#125;, decrement(state) &#123; state.count-- &#125; &#125;&#125;)export default store 在上面的代码中，我们创建了一个包含state和mutations的简单Vuex store。state用于存储应用程序的数据，mutations用于更改state中的数据。 3. 在Vue组件中使用Vuex 要在Vue组件中使用Vuex，您需要导入Vuex store并使用this.$store来访问状态和触发 mutations。以下是一个示例： 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;p&gt;Count: &#123;&#123; $store.state.count &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;Decrement&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; increment() &#123; this.$store.commit(&#x27;increment&#x27;) &#125;, decrement() &#123; this.$store.commit(&#x27;decrement&#x27;) &#125; &#125;&#125;&lt;/script&gt; 在上述代码中，我们使用$store.state.count来访问count状态，并使用this.$store.commit来触发increment和decrement mutations。 4. 在根Vue实例中添加Vuex store 最后，确保在根Vue实例中添加您的Vuex store： 123456789// main.jsimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import store from &#x27;./store&#x27; // 导入Vuex storenew Vue(&#123; render: h =&gt; h(App), store // 添加Vuex store&#125;).$mount(&#x27;#app&#x27;) 3. 核心概念3.1 State（状态） 概念：State 是应用程序的数据源，它包含应用程序中**&#x3D;&#x3D;所有组件共享的数据&#x3D;&#x3D;**。State 通常存储在一个单一的对象中，代表应用程序的当前状态。 示例： 123456// 在 Vuex store 中定义 stateconst store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;&#125;) 辅助函数-MapState ​ mapState 是 Vuex 提供的辅助函数之一，用于将 Vuex store 中的状态映射到组件的计算属性中，以便在组件中直接访问这些状态。这有助于简化组件代码并提高代码的可读性。使用 mapState，你可以将 Vuex store 中的状态与组件的计算属性相关联，而无需手动编写计算属性来获取状态值。 导入 mapState 函数：在你的组件文件中，导入 mapState 函数以及需要映射到计算属性的状态。例如： 12//XXX.vueimport &#123; mapState &#125; from &#x27;vuex&#x27;; 将状态映射到计算属性：在组件的 computed 部分，使用 mapState 函数将需要的状态映射为计算属性。例如： 1234567// xxx.vuecomputed: &#123; ...mapState(&#123; count: &#x27;count&#x27;, // 将 Vuex store 中的 &#x27;count&#x27; 映射为计算属性 &#x27;count&#x27; user: &#x27;user&#x27; // 将 Vuex store 中的 &#x27;user&#x27; 映射为计算属性 &#x27;user&#x27; &#125;)&#125; 在这个例子中，我们将 Vuex store 中的 ‘count’ 和 ‘user’ 映射为组件中的计算属性。 在组件中使用映射后的计算属性：现在你可以在组件中直接访问映射后的计算属性。例如： 12console.log(this.count); // 访问映射后的 &#x27;count&#x27; 计算属性console.log(this.user); // 访问映射后的 &#x27;user&#x27; 计算属性 3.2 Getters（计算属性） 概念：Getters 允许您从 state 中派生出一些数据，而无需在多个组件中重复编写计算属性。它们可以被认为是状态的计算属性。 示例： 1234567891011121314// 在 Vuex store 中定义 getterconst store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &#x27;Learn Vue&#x27;, done: true &#125;, &#123; id: 2, text: &#x27;Use Vuex&#x27;, done: false &#125; ] &#125;, getters: &#123; doneTodos (state) &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) 3.3 Mutations（变更） 概念：&#x3D;&#x3D;Mutations 是用来修改 state 的唯一途径&#x3D;&#x3D;。&#x3D;&#x3D;它们是同步函数&#x3D;&#x3D;，每个 mutation 都有一个字符串类型的事件类型和一个回调函数。通过 mutations，您可以跟踪状态的变化。 示例： 1234567891011// 在 Vuex store 中定义 mutationconst store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment: (state,参数) =&gt; &#123; state.count++ &#125; &#125;&#125;) 123// 在组件中提交 Mutationsthis.$store.commit(&#x27;increment&#x27;, 参数) // 增加计数器this.$store.commit(&#x27;decrement&#x27;, 参数) // 减少计数器 辅助函数-MapMutations ​ mapMutations 是 Vuex 提供的一个辅助函数，用于将组件的方法映射到 Vuex 中的 mutations，以便在组件中调用 mutations 而无需显式地编写 this.$store.commit。mapMutations 函数可以将组件中的方法映射为调用 mutations，你可以在组件中像调用本地方法一样调用这些映射后的方法。 导入 mapMutations 函数：在你的组件文件中，导入 mapMutations 函数和需要映射的 mutations。例如： 1import &#123; mapMutations &#125; from &#x27;vuex&#x27;; 将 mutations 映射到组件方法：在组件的 methods 中，使用 mapMutations 函数将需要的 mutations 映射为组件的方法。例如： 12345methods: &#123; //使用数组的方式 ...mapMutations([&#x27;increment&#x27;, &#x27;decrement&#x27;]), // 其他组件方法&#125; 在这个例子中，我们将名为 ‘increment’ 和 ‘decrement’ 的 mutations 映射为组件方法。 在组件中调用 mutations 方法：现在你可以在组件中调用映射后的方法来触发 mutations。例如： 12this.increment(); // 调用名为 &#x27;increment&#x27; 的 mutationthis.decrement(); // 调用名为 &#x27;decrement&#x27; 的 mutation 注：Mutations只能传递一个参数；若需要传递多个参数，可以通过传递对象或数组的方式。 V-model 不能绑定State，因为State中的值只能通过Mutations修改。 3.4 Actions（动作） 概念：&#x3D;&#x3D;Actions 用于执行异步操作&#x3D;&#x3D;，例如数据获取、API 调用等。&#x3D;&#x3D;它不能直接修改state，只能通过触发 mutations 来修改 state&#x3D;&#x3D;。Actions 本身也是函数，通常包含异步操作，最后再调用 mutations 来提交变更。 示例： 123456789101112131415161718// 在 Vuex store 中定义 actionconst store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state) &#123; state.count++ &#125; &#125;, actions: &#123; incrementAsync (context) &#123; setTimeout(() =&gt; &#123; context.commit(&#x27;increment&#x27;) // 调用 Mutations 来增加计数器 &#125;, 1000) &#125; &#125;&#125;) 12// 在组件中提交一个 Actionthis.$store.dispatch(&#x27;incrementAsync&#x27;) // 调用 incrementAsync Action 3.5 Modules（模块） 概念：Modules 允许您将 Vuex store 分割成多个小模块。每个模块有自己的 state、getters、mutations 和 actions，以帮助管理大型应用程序的复杂状态。 示例： 创建模块文件：在你的项目中创建一个模块文件（例如 myModule.js）来定义模块的 state、mutations、actions 和 getters。 123456789101112131415161718192021222324252627282930313233343536// myModule.jsconst state = &#123; // 模块自己的状态 count: 0&#125;;const mutations = &#123; // 模块自己的mutations increment(state) &#123; state.count++; &#125;&#125;;const actions = &#123; // 模块自己的actions incrementAsync(&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit(&#x27;increment&#x27;); &#125;, 1000); &#125;&#125;;const getters = &#123; // 模块自己的getters doubleCount(state) &#123; return state.count * 2; &#125;&#125;;export default &#123; state, mutations, actions, getters&#125;; 在 Vuex 中注册模块：在你的 Vuex store 中注册模块，以便在应用程序中使用它。在你的 store.js 文件中： 12345678910111213141516//store.js文件import Vue from &#x27;vue&#x27;;import Vuex from &#x27;vuex&#x27;;import myModule from &#x27;./myModule&#x27;; // 导入模块Vue.use(Vuex);const store = new Vuex.Store(&#123; modules: &#123; // 注册模块 myModule &#125; // ...其他配置&#125;);export default store; 在组件中使用模块：在你的组件中，可以通过模块名称访问模块的状态、mutations、actions 和 getters。例如： 1234567891011// 从模块中获取状态const count = this.$store.state.myModule.count;// 调用模块中的mutationthis.$store.commit(&#x27;myModule/increment&#x27;);// 调用模块中的actionthis.$store.dispatch(&#x27;myModule/incrementAsync&#x27;);// 从模块中获取getterconst doubleCount = this.$store.getters[&#x27;myModule/doubleCount&#x27;]; 3.6 Store（仓库） 概念：Store 是应用程序状态的单一源头，包含 state、getters、mutations、actions 和 modules。一个应用程序通常只有一个 store，可以在根 Vue 实例中导入和使用。 示例： 12345678910111213// 创建 Vuex storeconst store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment: state =&gt; &#123; state.count++ &#125; &#125; // ...&#125;)// 在根 Vue 实例中使用 storenew Vue(&#123; el: &#x27;#app&#x27;, store, // 注入 store 到根组件 // ...&#125;) 3.7 单向数据流 概念：在 Vuex 中，数据流是单向的，从 state 到视图，然后通过 actions 到 mutations，最终更新 state。这种单向数据流使应用程序的状态管理变得可控和可预测。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Vue指令","slug":"2. Vue指令","date":"2023-10-30T16:00:00.000Z","updated":"2023-10-31T06:01:25.198Z","comments":true,"path":"2023/10/31/2. Vue指令/","link":"","permalink":"http://example.com/2023/10/31/2.%20Vue%E6%8C%87%E4%BB%A4/","excerpt":"","text":"1. 基础指令1.1 条件渲染指令这类指令用于根据条件动态地渲染或隐藏HTML元素。其中，最常用的指令是v-else、v-if和v-show。 **v-if**根据表达式的值的真假，条件性地渲染或不渲染元素。当表达式的值为真时，元素会被渲染；否则，元素将不会被渲染。 v-show根据表达式的值的真假，条件性地显示或隐藏元素。当表达式的值为真时，元素将被显示；否则，元素将被隐藏。与v-if不同的是，v-show指令不会在DOM树中添加或删除元素，只是根据条件决定元素的CSS属性display。 注：v-if会添加或删除Dom元素，不适用DOM元素频繁显示-关闭的场景。v-show不会添加删除Dom元素。 1.2 列表渲染指令这类指令用于循环渲染HTML元素，通常用于渲染列表或表格。其中，最常用的指令是v-for。v-for用于在一个数组或对象上循环渲染元素。语法为v-for=&quot;item in items&quot;，其中item是当前循环的项，items是要循环的数组或对象。可以使用v-for的参数来控制循环输出。 123456&lt;ul&gt; &lt;li v-for=&#x27;(index, item) in items&#x27;&gt; &lt;p&gt;&#123;&#123; item.name &#125;&#125;&lt;/p&gt; ………… &lt;/li&gt;&lt;/ul&gt; 1.3 双向数据绑定指令（表单绑定指令）这类指令用于将表单元素的值与Vue实例中的数据双向绑定。其中，最常用的指令是v-model。v-model用于在表单元素和Vue实例中的数据之间建立双向绑定关系。例如，在一个文本输入框中，v-model可以将用户输入的值存储在Vue实例中的数据中，并且在Vue实例中的数据发生变化时，也会自动更新文本框的值。 1&lt;input v-model=&quot;text&quot;&gt; v-model指令的修饰符： .trim—删除文本首尾空格 .number—文本转数字 1.4 事件处理指令这类指令用于绑定HTML元素的事件，例如点击事件、键盘事件等。其中，最常用的指令是v-on。v-on用于绑定HTML元素的事件监听器，例如**v-on:click**用于监听元素的点击事件。当事件被触发时，绑定的方法将被调用。可以使用v-on的参数来指定要绑定的事件类型。 123456789101112131415161718data() &#123; return &#123; name: &#x27;Vue.js&#x27; &#125;&#125;,methods: &#123; greet(event) &#123; // 方法中的 `this` 指向当前活跃的组件实例 alert(`Hello $&#123;this.name&#125;!`) // `event` 是 DOM 原生事件 if (event) &#123; alert(event.target.tagName) &#125; &#125;&#125;&lt;!-- `greet` 是上面定义过的方法名 --&gt;&lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt; 注：v-on:click可以简写为@click 1.5 属性绑定指令这类指令用于将HTML元素的属性与Vue实例中的数据绑定。其中，最常用的指令是v-bind。v-bind用于将HTML元素的属性与Vue实例中的数据绑定。例如，v-bind:class=&quot;&#123;red: isRed&#125;&quot;可以根据Vue实例中的isRed数据来动态地添加或删除red类。可以使用v-bind的参数来指定要绑定的属性。 注：v-bind:class可以简写为：class 2. 自定义指令Vue.js允许你创建自定义指令（Custom Directives），这些指令是在Vue模板中使用的特殊标记，用于对DOM元素进行操作、绑定事件、添加动画等。你可以根据项目的需求创建自定义指令，以扩展Vue的功能。以下是创建和使用自定义指令的一般步骤： 2.1 全局自定义指令你可以在Vue应用的入口文件（通常是main.js）中全局注册自定义指令。使用Vue.directive方法来创建全局指令，例如： 1234567891011121314151617// main.jsimport Vue from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;// 创建一个全局自定义指令 `v-highlight`Vue.directive(&#x27;highlight&#x27;, &#123; // 绑定时调用 bind(el, binding) &#123; // 设置元素的背景颜色为指令的参数值 el.style.backgroundColor = binding.value; &#125;&#125;);new Vue(&#123; render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;); 2.2 局部自定义指令如果你只想在特定组件中使用自定义指令，你可以在组件的directives选项中注册指令。例如： 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;p v-highlight=&quot;&#x27;yellow&#x27;&quot;&gt;这个段落被高亮了。&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; directives: &#123; highlight: &#123; bind(el, binding) &#123; el.style.backgroundColor = binding.value; &#125; &#125; &#125;&#125;;&lt;/script&gt; 2.3 使用自定义指令在模板中使用自定义指令时，你可以在指令名后面传递参数，如v-highlight=&quot;&#39;yellow&#39;&quot;，参数的值会被传递到指令的bind方法中。 2.4 指令生命周期钩子自定义指令可以定义生命周期钩子函数，用于在指令绑定时、元素更新时或解绑时执行特定操作。常用的钩子函数包括： bind：指令绑定到元素时调用。 inserted：元素插入到父节点时调用。 update：元素及其子节点更新时调用。 componentUpdated：组件及其子组件更新时调用。 unbind：指令与元素解绑时调用。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Vue组件","slug":"3. Vue组件","date":"2023-10-30T16:00:00.000Z","updated":"2023-10-31T06:01:23.546Z","comments":true,"path":"2023/10/31/3. Vue组件/","link":"","permalink":"http://example.com/2023/10/31/3.%20Vue%E7%BB%84%E4%BB%B6/","excerpt":"","text":"1. 单文件组件在大多数启用了构建工具的 Vue 项目中，我们可以使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 (也被称为 *.vue 文件，英文 Single-File Components，缩写为 SFC)。顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。下面我们将用单文件组件的格式重写计数器示例： 12345678910111213141516171819202122//逻辑&lt;script&gt;export default &#123; data() &#123; return &#123; count: 0 &#125; &#125;&#125;&lt;/script&gt;//模板&lt;template&gt; &lt;button @click=&quot;count++&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;//样式&lt;style scoped&gt;button &#123; font-weight: bold;&#125;&lt;/style&gt; 2. 组件选项 Vue.js 组件中的一些常见属性和选项： data：一个函数，返回包含组件内部数据的对象。这些数据在组件的模板中使用，用于渲染视图。 computed：包含计算属性的对象，计算属性允许你根据已有的数据属性计算派生值。 methods：包含组件方法的对象，可以在模板中触发。 props：用于接收父组件传递的数据，定义组件的输入。 propsData：用于测试，手动传递 props 数据。 emits：定义组件的自定义事件。 setup：用于 Composition API，提供组件的配置和响应式数据。 components：包含局部注册的子组件。 directives：包含局部注册的自定义指令。 filters：包含局部注册的自定义过滤器。 watch：用于观察数据的变化，执行相应的操作。 mixins：包含混入（Mixins）对象的数组，用于共享组件选项。 extends：用于继承另一个组件的选项。 provide 和 inject：用于父子组件之间的依赖注入。 inheritAttrs：控制是否将非props属性传递给根元素。 name：定义组件的名称。 model：配置 v-model 的默认行为。 delimiters：自定义插值表达式的分隔符。 comments：控制是否保留模板编译时的注释。 functional：使组件无状态和无实例，通常用于函数式组件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=&quot;task in tasks&quot; :key=&quot;task.id&quot;&gt; &#123;&#123; task.title &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;addTask&quot;&gt;Add Task&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // 组件的名称 name: &#x27;TodoList&#x27;, // 父组件传递的属性 props: &#123; title: String, initialTasks: Array, &#125;, // 组件内部数据 data() &#123; return &#123; tasks: this.initialTasks, &#125;; &#125;, // 计算属性 computed: &#123; taskCount() &#123; return this.tasks.length; &#125;, &#125;, // 组件方法 methods: &#123; addTask() &#123; const newTask = &#123; id: this.taskCount + 1, title: `Task $&#123;this.taskCount + 1&#125;`, &#125;; this.tasks.push(newTask); &#125;, &#125;, // 观察数据变化 watch: &#123; tasks(newTasks) &#123; console.log(&#x27;Tasks have changed:&#x27;, newTasks); &#125;, &#125;, // 自定义指令 directives: &#123; focus: &#123; inserted(el) &#123; el.focus(); &#125;, &#125;, &#125;, filters: &#123; // 自定义过滤器 capitalize(value) &#123; return value.charAt(0).toUpperCase() + value.slice(1); &#125;, &#125;, // 局部注册子组件 components: &#123; TaskItem: &#123; template: &#x27;&lt;div&gt;&#123;&#123; task.title | capitalize &#125;&#125;&lt;/div&gt;&#x27;, props: [&#x27;task&#x27;], &#125;, &#125;, // 配置v-model的默认行为 model: &#123; prop: &#x27;checked&#x27;, event: &#x27;change&#x27;, &#125;, // 提供依赖注入 provide() &#123; return &#123; todoList: this, &#125;; &#125;,&#125;;&lt;/script&gt; 3. 组件注册3.1全局注册我们可以使用 Vue 应用实例的 app.component() 方法，让组件在当前 Vue 应用中全局可用。全局注册的组件可以在此应用的任意组件的模板中使用。具体步骤如下： 创建组件（XXX.vue文件） Main.js文件中进行全局注册 12345678910111213// main.js文件import &#123; createApp &#125; from &#x27;vue&#x27;const app = createApp(&#123;&#125;)app.component( // 注册的名字 &#x27;MyComponent&#x27;, // 组件的实现 &#123; /* ... */ &#125;) 如果使用单文件组件，你可以注册被导入的 .vue 文件： 12import MyComponent from &#x27;./App.vue&#x27;app.component(&#x27;MyComponent&#x27;, MyComponent) app.component() 方法可以被链式调用： 1234app .component(&#x27;ComponentA&#x27;, ComponentA) .component(&#x27;ComponentB&#x27;, ComponentB) .component(&#x27;ComponentC&#x27;, ComponentC) 1234&lt;!-- 这在当前应用的任意组件中都可用 --&gt;&lt;ComponentA/&gt;&lt;ComponentB/&gt;&lt;ComponentC/&gt; 注：所有的子组件也可以使用全局注册的组件，这意味着这三个组件也都可以在彼此内部使用。 3.2局部注册全局注册虽然很方便，但有以下几个问题： 全局注册，但并没有被使用的组件无法在生产打包时被自动移除 (也叫“tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的 JS 文件中。 全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。 相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking 更加友好。 局部注册需要使用 components 选项： 12345678910111213141516&lt;script&gt;//1. 先引入组件import ComponentA from &#x27;./ComponentA.vue&#x27;export default &#123; //2. 组件注册 components: &#123; ComponentA &#125;&#125;&lt;/script&gt;&lt;template&gt; //3.使用组件 &lt;ComponentA /&gt;&lt;/template&gt; 对于每个 components 对象里的属性，它们的 key 名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015 的缩写语法，等价于： 123456export default &#123; components: &#123; ComponentA: ComponentA &#125; // ...&#125; 注：局部注册的组件在后代组件中并不可用。在这个例zi中，ComponentA 注册后仅在当前组件可用，而在任何的子组件或更深层的子组件中都不可用。 4. 组件通信4.1 父子组件通信4.1.1 父→子父子组件通信是Vue.js中最常见的一种组件通信方式。父组件使用 :message=&quot;parentMessage&quot; 将数据传递给子组件。子组件通过 props: [&quot;message&quot;] 来接收这个数据，并在模板中显示它。父组件可以随时更新parentMessage的值，子组件将根据新的值进行更新。 父组件（ParentComponent.vue）： 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;h1&gt;父组件&lt;/h1&gt; &lt;ChildComponent :message=&quot;parentMessage&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComponent from &quot;./ChildComponent.vue&quot;;export default &#123; components: &#123; ChildComponent, &#125;, data() &#123; return &#123; parentMessage: &quot;这是来自父组件的消息&quot;, &#125;; &#125;,&#125;;&lt;/script&gt; 子组件（ChildComponent.vue）： 123456789101112&lt;template&gt; &lt;div&gt; &lt;h2&gt;子组件&lt;/h2&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: [&quot;message&quot;],&#125;;&lt;/script&gt; 4.1.2 子→父在Vue.js中，子组件向父组件传递数据通常使用自定义事件（Custom Events）来实现。这允许子组件触发事件，然后父组件可以监听这些事件并响应子组件的操作。以下是一个示例，演示如何在子组件中触发自定义事件并将数据传递给父组件： 子组件触发自定义事件（子组件）：子组件通过 $emit 方法触发名为 “custom-event” 的自定义事件，并将数据传递给父组件。 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;sendDataToParent&quot;&gt;向父组件传递数据&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; sendDataToParent() &#123; const data = &quot;这是来自子组件的数据&quot;; this.$emit(&quot;custom-event&quot;, data); // 触发自定义事件并传递数据 &#125;, &#125;,&#125;;&lt;/script&gt; 父组件监听自定义事件（父组件）：在父组件中，我们通过 @custom-event=&quot;handleChildEvent&quot; 监听子组件触发的自定义事件，并在事件触发时调用 handleChildEvent 方法来接收子组件传递的数据。 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;h1&gt;父组件&lt;/h1&gt; &lt;p&gt;从子组件接收的数据: &#123;&#123; receivedData &#125;&#125;&lt;/p&gt; &lt;child-component @custom-event=&quot;handleChildEvent&quot;&gt;&lt;/child-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComponent from &quot;./ChildComponent.vue&quot;;export default &#123; components: &#123; ChildComponent, &#125;, data() &#123; return &#123; receivedData: &quot;&quot;, &#125;; &#125;, methods: &#123; handleChildEvent(data) &#123; this.receivedData = data; // 处理来自子组件的数据 &#125;, &#125;,&#125;;&lt;/script&gt; 4.2 非父子组件通信非父子组件通信通常需要一种全局状态管理的机制，以便不同组件之间能够共享数据和进行通信。Vue.js 提供了一些方式来实现非父子组件之间的通信，其中包括使用事件总线、Vuex（状态管理库）和 provide&#x2F;inject。下面我将介绍这些方式。 4.2.1 事件总线 (Event Bus)事件总线是一个Vue实例，你可以用它来触发和监听事件。创建一个事件总线，然后在需要通信的组件中使用 $emit 触发事件，并使用 $on 监听事件。 创建事件总线（event-bus.js）： 12import Vue from &#x27;vue&#x27;;export const EventBus = new Vue(); 接收方组件 1234// 监听事件EventBus.$on(&#x27;my-event&#x27;, (data) =&gt; &#123; // 处理数据&#125;); 发送方组件 12// 发送事件EventBus.$emit(&#x27;my-event&#x27;, data); 4.2.2 provide&#x2F;injectVue 提供了 provide 和 inject 选项，允许祖先组件提供数据，然后后代组件使用 inject 来接收这些数据。这对于祖先和后代组件之间的通信非常有用。 祖先组件（provide-data.vue）： 123456789&lt;script&gt;export default &#123; provide() &#123; return &#123; sharedData: &#x27;这是共享的数据&#x27;, &#125;; &#125;,&#125;;&lt;/script&gt; 后代组件（consume-data.vue）： 1234567891011&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123; sharedData &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; inject: [&#x27;sharedData&#x27;],&#125;;&lt;/script&gt; 4.2.3 Vuex 状态管理库 Vuex 是一个专门用于状态管理的库，允许你在整个应用程序中共享状态。你可以在任何组件中访问和修改状态，以及触发事件。它提供了一个中央存储，包括状态、mutations、actions和getters。 安装和配置 Vuex，然后在组件中使用 this.$store 访问状态和触发 mutations 和 actions。 4.2.4 作用域插槽详见章节 5.3 5. 插槽在Vue.js中，插槽（Slot）是一种用于在组件之间传递内容的机制，它允许你将内容插入到组件的特定位置。插槽是一种强大的抽象，它使得组件更加灵活和可重用，允许开发者在不同情况下自定义组件的外观和行为。 通过使用插槽，你可以将任何内容插入到组件中，使组件更加灵活和可定制。插槽是Vue.js组件化开发的一个关键特性，它有助于构建可重用的组件，同时允许开发者根据需要自定义组件的外观和内容。 5.1 默认插槽默认插槽是组件中未命名的插槽，它用于插入未分配到任何具名插槽的内容。默认插槽通常用在组件的模板中，使用&lt;slot&gt;&lt;/slot&gt;标签定义。 子组件定义插槽： 1234567&lt;template&gt; &lt;div&gt; &lt;h1&gt;默认插槽示例&lt;/h1&gt; //插槽位置 &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 父组件使用插槽： 123&lt;my-component&gt; &lt;p&gt;This is the main content.&lt;/p&gt;&lt;/my-component&gt; 5.2 具名插槽具名插槽是具有名称的插槽，允许你在父组件中选择性地将内容插入到组件的特定位置。具名插槽可以在父组件中使用&lt;template v-slot:slotName&gt;&lt;/template&gt;标签来定义。 子组件定义插槽： 123456789&lt;template&gt; &lt;div&gt; &lt;h1&gt;具名插槽示例&lt;/h1&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;div class=&quot;content&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 在父组件中使用具名插槽：template标签配合#插槽名 1234567891011121314&lt;my-component&gt; &lt;template v-slot:header&gt; &lt;h2&gt;This is the header&lt;/h2&gt; &lt;/template&gt; &lt;p&gt;This is the main content.&lt;/p&gt;&lt;/my-component&gt;//简化写法&lt;my-component&gt; &lt;template #header&gt; &lt;h2&gt;This is the header&lt;/h2&gt; &lt;/template&gt; &lt;p&gt;This is the main content.&lt;/p&gt;&lt;/my-component&gt; 5.3 作用域插槽通过插槽（Slot）传递值通常需要结合使用具名插槽和作用域插槽（Scoped Slot）。这使得在父组件中将数据传递到插槽中成为可能。以下是一个示例，演示如何通过插槽传递值。在这个示例中，组件A定义了一个具名插槽，用于传递消息。组件B使用了组件A，并在插槽中接收消息。组件B还包含了一个按钮，当点击按钮时，会调用一个方法来显示消息。 组件A定义具名插槽：组件A使用:message=&quot;slotMessage&quot;将数据绑定到插槽。默认插槽名为default。 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;slot :message=&quot;slotMessage&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; slotMessage: &quot;这是组件A传递的消息&quot;, &#125;; &#125;,&#125;;&lt;/script&gt; 组件B接受插槽传递值： 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;h1&gt;组件B&lt;/h1&gt; &lt;component-a&gt; //默认插槽名为default &lt;template v-slot:default=&quot;slotProps&quot;&gt; &lt;p&gt;组件B收到的消息: &#123;&#123; slotProps.message &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;showMessage(slotProps.message)&quot;&gt;显示消息&lt;/button&gt; &lt;/template&gt; &lt;/component-a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ComponentA from &quot;./ComponentA.vue&quot;;export default &#123; components: &#123; ComponentA, &#125;, methods: &#123; showMessage(message) &#123; alert(message); &#125;, &#125;,&#125;;&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Vue生命周期","slug":"5. Vue生命周期","date":"2023-10-30T16:00:00.000Z","updated":"2023-10-31T06:01:21.576Z","comments":true,"path":"2023/10/31/5. Vue生命周期/","link":"","permalink":"http://example.com/2023/10/31/5.%20Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"1. Vue生命周期 2. Vue生命周期函数Vue.js 是一个流行的 JavaScript 框架，它有自己的生命周期钩子函数，允许你在组件不同生命周期阶段执行代码。Vue 组件的生命周期包括以下钩子函数： beforeCreate：在实例被创建之前调用。此时组件的数据观察和事件配置都尚未初始化。 **&#x3D;&#x3D;created&#x3D;&#x3D;**：在实例被创建之后调用。在这个阶段，组件已经完成数据观察、属性和方法的运算，但尚未挂载到DOM。 beforeMount：在挂载开始之前被调用。此时，模板编译已完成，但尚未将模板渲染到DOM中。 **&#x3D;&#x3D;mounted&#x3D;&#x3D;**：在挂载完成后调用。此时，组件已经被挂载到DOM中，可以访问DOM元素。 beforeUpdate：在数据更新之前调用。当数据发生变化时，该钩子函数会在重新渲染之前被触发。 updated：在数据更新完成后调用。组件已经重新渲染并应用了变化的数据。 beforeDestroy：在组件销毁之前调用。可以在这个阶段进行一些清理工作，如清除定时器、取消订阅等。 destroyed：在组件销毁后调用。此时，组件实例已经被销毁，所有的事件监听器和数据观察都已经被解绑。 以下是一个简单的 Vue 组件示例，展示了这些生命周期钩子函数的执行顺序： 123456789101112131415161718192021222324252627282930new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello, Vue!&#x27; &#125;, beforeCreate: function() &#123; console.log(&#x27;beforeCreate hook&#x27;); &#125;, created: function() &#123; console.log(&#x27;created hook&#x27;); &#125;, beforeMount: function() &#123; console.log(&#x27;beforeMount hook&#x27;); &#125;, mounted: function() &#123; console.log(&#x27;mounted hook&#x27;); &#125;, beforeUpdate: function() &#123; console.log(&#x27;beforeUpdate hook&#x27;); &#125;, updated: function() &#123; console.log(&#x27;updated hook&#x27;); &#125;, beforeDestroy: function() &#123; console.log(&#x27;beforeDestroy hook&#x27;); &#125;, destroyed: function() &#123; console.log(&#x27;destroyed hook&#x27;); &#125;&#125;); 当你创建一个 Vue 实例时，这些钩子函数会按照上述顺序被依次调用。你可以在这些钩子函数中执行特定的逻辑，以满足你的应用程序需求。例如，在 mounted 钩子中，你可以执行DOM操作或向后端服务器发送请求。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Vue-router","slug":"7. Vue-router","date":"2023-10-30T16:00:00.000Z","updated":"2023-10-31T06:01:19.654Z","comments":true,"path":"2023/10/31/7. Vue-router/","link":"","permalink":"http://example.com/2023/10/31/7.%20Vue-router/","excerpt":"","text":"##1. 简介 Vue Router（通常称为 vue-router）是Vue.js的官方路由管理库，用于实现前端路由。Vue Router使你能够创建单页面应用（SPA），将不同的组件与URL进行关联，以便用户在应用程序中导航。以下是Vue Router的基本 2. 使用教程步骤1: 安装Vue Router首先，确保你的Vue.js项目已经安装了Vue Router。如果你是使用Vue CLI创建的项目，通常Vue Router会自动包含在项目中。如果没有，你可以通过以下方式进行安装： 1npm install vue-router 或者使用Yarn： 1yarn add vue-router 步骤2: 创建路由配置在你的项目中创建一个路由配置（route&#x2F;index.js），定义路由的路径和关联的组件。通常，你会将路由配置放在一个单独的文件中。以下是一个简单的路由配置示例： 12345678910111213141516171819202122232425// router/index.jsimport Vue from &#x27;vue&#x27;;import VueRouter from &#x27;vue-router&#x27;;import Home from &#x27;@/views/Home.vue&#x27;;import About from &#x27;@/views/About.vue&#x27;;Vue.use(VueRouter);const routes = [ &#123; path: &#x27;/&#x27;, component: Home, &#125;, &#123; path: &#x27;/about&#x27;, component: About, &#125;,];const router = new VueRouter(&#123; routes,&#125;);export default router; 步骤3: 关联Vue实例在你的Vue应用程序中，你需要将Vue Router与Vue实例关联，以便它能够控制你的应用的路由。通常，你会在主入口文件（例如main.js）中执行此操作： 12345678import Vue from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;import router from &#x27;./router&#x27;;new Vue(&#123; render: h =&gt; h(App), router, // 将路由器与Vue实例关联&#125;).$mount(&#x27;#app&#x27;); 步骤4: 创建路由视图在你的应用程序中，创建与路由关联的组件，并将它们渲染为路由视图。路由视图是在不同路由之间切换时显示的内容区域。你可以在Vue组件中使用 &lt;router-view&gt; 标签来显示路由视图。 123456&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 步骤5: 创建导航链接为了让用户能够导航到不同的路由，你可以创建导航链接。Vue Router提供了 &lt;router-link&gt; 组件，用于创建内部导航链接。以下是一个简单的示例： 12&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; 步骤6: 导航守卫Vue Router提供了导航守卫，你可以使用它们来添加路由导航的拦截和处理逻辑。你可以在路由配置中定义全局守卫、路由独享的守卫以及组件内的守卫。 以下是一个全局前置守卫的示例，它在每次路由切换前执行： 12345678const router = new VueRouter(&#123; routes,&#125;);router.beforeEach((to, from, next) =&gt; &#123; // 在每次路由切换前执行的逻辑 next(); // 一定要调用 next() 来继续路由导航&#125;); 这是一个简单的Vue Router使用教程，帮助你开始创建具有路由功能的Vue.js应用程序。根据你的项目需求，你可以添加更多高级功能，如嵌套路由、路由参数、路由懒加载等。请查阅Vue Router的官方文档以获取更多详细信息：Vue Router 官方文档。 3. 嵌套路由 嵌套路由是一种在Vue Router中创建子路由的技术，允许你在一个父路由内嵌套多个子路由。这对于构建复杂的页面布局以及在不同的嵌套级别上组织组件非常有用。 步骤1：定义路由配置首先，你需要在路由配置中定义父路由和子路由。父路由通常是页面的整体布局，而子路由用于在父路由内呈现不同的内容。 123456789101112131415161718const routes = [ &#123; path: &#x27;/&#x27;, component: Layout, // 父路由组件 children: [ &#123; path: &#x27;&#x27;, // 子路由的路径为空，作为默认子路由 component: Home, // 子路由组件 &#125;, &#123; path: &#x27;about&#x27;, component: About, &#125;, // 其他子路由 ], &#125;, // 其他路由配置]; 步骤2：创建路由视图组件在父路由组件和子路由组件中，你需要创建Vue组件，以便在路由切换时呈现内容。 1234567891011121314151617181920212223242526&lt;!-- Layout.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;Layout&lt;/h1&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 子路由组件将被渲染在这里 --&gt; &lt;/div&gt;&lt;/template&gt;vueCopy code&lt;!-- Home.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;Home Page&lt;/h2&gt; &lt;!-- Home 页面内容 --&gt; &lt;/div&gt;&lt;/template&gt;vueCopy code&lt;!-- About.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;About Page&lt;/h2&gt; &lt;!-- About 页面内容 --&gt; &lt;/div&gt;&lt;/template&gt; 步骤3：设置路由链接你可以使用 &lt;router-link&gt; 组件创建导航链接，以便用户可以导航到不同的子路由。 1234&lt;!-- Layout.vue 或其他父路由组件 --&gt;&lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt;&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; 步骤4：导航到子路由现在，当用户点击导航链接时，Vue Router将会根据路径切换到相应的子路由，该子路由将在父路由的 &lt;router-view&gt; 中呈现。 这就是嵌套路由的基本使用方法。你可以在父路由中定义更多的子路由，以构建复杂的页面布局和导航。请查阅Vue Router官方文档以了解更多关于嵌套路由的高级用法和选项：Vue Router 嵌套路由。 4. 路由参数（声明式导航）在Vue Router中，你可以使用不同的方式来传递参数，包括查询参数（Query Parameters）和动态路由（Dynamic Routing）。这两种方法都可以用于在路由之间传递数据，但适用于不同的使用场景。 查询参数适用于在URL中传递参数，适用于不同路由之间的通用参数。而动态路由适用于根据参数值定位到不同的路由，并在组件内部使用参数。选择哪种方式取决于你的项目需求。通常，查询参数更适合用于筛选、排序、分页等功能，而动态路由更适合用于页面间的导航和路由跳转。 4.1 查询参数传参查询参数是附加在URL中的键值对，通常出现在URL的问号后面（例如：http://example.com/route?param1=value1&amp;param2=value2）。 传递查询参数： 使用 &lt;router-link&gt; 或编程方式导航时，你可以将查询参数附加到路由中。 使用 &lt;router-link&gt;： 1&lt;router-link :to=&quot;&#123; path: &#x27;/route&#x27;, query: &#123; param1: &#x27;value1&#x27;, param2: &#x27;value2&#x27; &#125; &#125;&quot;&gt;Go to Route&lt;/router-link&gt; 或者，使用编程方式： 1this.$router.push(&#123; path: &#x27;/route&#x27;, query: &#123; param1: &#x27;value1&#x27;, param2: &#x27;value2&#x27; &#125; &#125;); 接收查询参数： 在目标组件中，你可以通过 $route.query 来访问查询参数的值。 123456&lt;template&gt; &lt;div&gt; &lt;p&gt;Param1: &#123;&#123; $route.query.param1 &#125;&#125;&lt;/p&gt; &lt;p&gt;Param2: &#123;&#123; $route.query.param2 &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 4.2 动态路由传参动态路由允许你在路由路径中包含参数，这些参数可以在路由匹配时传递到组件中。 定义动态路由：在路由配置中，你可以使用冒号 : 来定义动态参数。 123456const routes = [ &#123; path: &#x27;/route/:param1/:param2&#x27;, component: YourComponent, &#125;,]; 传递动态参数：在使用 &lt;router-link&gt; 或编程方式导航时，你可以为动态参数提供相应的值。 1&lt;router-link :to=&quot;&#123; path: &#x27;/route/value1/value2&#x27; &#125;&quot;&gt;Go to Route&lt;/router-link&gt; 或者，使用编程方式： 1this.$router.push(&#123; path: &#x27;/route/value1/value2&#x27; &#125;); 接收动态参数：在目标组件中，你可以通过 $route.params 来访问动态参数的值。 123456789101112&lt;template&gt; &lt;div&gt; &lt;p&gt;Param1: &#123;&#123; $route.params.param1 &#125;&#125;&lt;/p&gt; &lt;p&gt;Param2: &#123;&#123; $route.params.param2 &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; //在js中需要使用this关键字 this.$route.params.param2&lt;/script&gt; 参数可选符： 当我们使用动态路由传参时，如果路由中配置了参数，则我们必须要传递参数，否则就会出现显示空白的情况。若我们希望参数可以选择性传递，则需要在配置路由时添加参数可选符——“ ? “。 123456const routes = [ &#123; path: &#x27;/route/:param1?&#x27;, component: YourComponent, &#125;,]; 4.3 小结 方式 传递参数 接收参数 配置路由 查询参数传参 to &#x3D; “&#x2F;path?参数名&#x3D;值&amp;参数名&#x3D;值” $route.query.参数名 无 动态路由传参 to &#x3D; “&#x2F;path&#x2F;参数名” $route.params.参数名 path:”&#x2F;path&#x2F;参数名” 5. 路由重定向路由重定向是一种Vue Router中的常见用法，它允许你在导航到某个路由时，自动将用户重定向到另一个路由。这可以用于多种情况，例如在用户访问某个路径时自动跳转到登录页、实现别名路由、或者重定向到默认页面等。 5.1 使用 redirect 属性在路由配置中，你可以为某个路由配置 redirect 属性，将其值设置为要重定向到的路由路径。这会将用户从一个路由自动导航到另一个路由。 1234567const routes = [ &#123; path: &#x27;/old-path&#x27;, redirect: &#x27;/new-path&#x27;, // 将用户重定向到 /new-path &#125;, // 其他路由配置]; 5.2 使用命名路由如果你使用了命名路由，你可以在 redirect 属性中使用命名路由来执行重定向。 1234567const routes = [ &#123; path: &#x27;/old-path&#x27;, redirect: &#123; name: &#x27;new-route-name&#x27; &#125;, // 通过命名路由重定向 &#125;, // 其他路由配置]; 5.3 使用函数你还可以在 redirect 属性中使用一个函数，以编程方式决定要重定向到的路由。 12345678910const routes = [ &#123; path: &#x27;/old-path&#x27;, redirect: (to) =&gt; &#123; // 在这里编写逻辑，根据 to 对象来决定重定向的路由 return &#x27;/new-path&#x27;; &#125;, &#125;, // 其他路由配置]; 5.4 路由别名Vue Router还提供了路由别名的功能，允许你将某个路由设置为另一个路由的别名，当用户访问别名路由时，实际上是访问了目标路由。这可以被认为是一种路由重定向，但更为简单。 12345678const routes = [ &#123; path: &#x27;/alias-path&#x27;, // 路由别名 alias: &#x27;/target-path&#x27;, // 设置别名为 /target-path component: SomeComponent, // 显示的组件 &#125;, // 其他路由配置]; 通过路由别名，用户可以访问 /alias-path 或 /target-path，它们将显示相同的组件。 123456789const routes = [ &#123; path: &#x27;/old-path&#x27;, redirect: &#x27;/new-path&#x27;, // 将用户重定向到 /new-path &#125;, &#123; // 其他路由配置 &#125;]; 6. 编程式导航6.1 路由跳转编程式导航是通过JavaScript代码来手动执行路由导航，通常使用 $router 对象的方法，如 push、replace、go 等。它通常用于以下情况： 当你需要在响应事件、异步操作或特定逻辑之后手动执行路由导航。 当你需要传递参数、执行条件导航或在导航完成后执行额外的操作时。 1234567891011121314methods: &#123; navigateToAboutPage() &#123; this.$router.push(&#x27;/about&#x27;); // 编程式导航到 About 页面 &#125;&#125;//完整写法methods: &#123; navigateToAboutPage() &#123; this.$router.push(&#123; path:&#x27;路由路径&#x27; &#125;); &#125;&#125; 6.2 路由传参 使用 params 传递参数（动态路由传参）： 步骤1：在路由配置中定义动态路由：首先，需要在路由配置中定义一个带有动态参数的路由。 12345678javascriptCopy codeconst routes = [ &#123; path: &#x27;/user/:id&#x27;, component: UserProfile, &#125;, // 其他路由配置]; 步骤2：执行编程式导航并传递参数**：使用 $router.push() 方法来执行编程式导航，并在其中传递参数。 1this.$router.push(&#123; path: &#x27;/user/123&#x27; &#125;); // 传递参数，将用户ID设置为123 步骤3：接收参数的组件中访问参数：在目标组件中，你可以通过 $route.params 来访问传递的参数。 12345&lt;template&gt; &lt;div&gt; &lt;p&gt;User ID: &#123;&#123; $route.params.id &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 使用 query 传递参数（查询参数传参）： 步骤1：执行编程式导航并传递参数：使用 $router.push() 方法来执行编程式导航，并在其中传递参数作为查询参数。 1234this.$router.push(&#123; path: &#x27;/user&#x27;, query: &#123; id: 123 &#125; &#125;); // 传递参数，将用户ID设置为123 步骤2：在接收参数的组件中访问参数：在目标组件中，你可以通过 $route.query 来访问传递的查询参数。 12345&lt;template&gt; &lt;div&gt; &lt;p&gt;User ID: &#123;&#123; $route.query.id &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 这是两种使用编程式导航传递参数的常见方法。你可以根据你的需求和路由配置选择其中一种方式。一般来说，使用 params 适用于将参数嵌入到URL中，而使用 query 适用于更灵活的参数传递，例如在表单提交后传递数据。如果需要更多复杂的参数传递，你还可以结合这两种方法来使用。 7. 路由懒加载路由懒加载（Route Lazy Loading）是一种优化Vue.js应用性能的技术。通过路由懒加载，你可以延迟加载你的路由组件，只在用户访问特定路由时才加载相关的代码。这可以减小初始加载的包大小，加快应用的初始加载速度，特别是对于大型单页应用（SPA）来说非常有用。在Vue.js中，你可以使用以下方法实现路由懒加载： 7.1 使用动态导入（Dynamic Import）动态导入是ECMAScript的一部分，它允许你按需加载模块。在Vue.js中，你可以结合Webpack的动态导入来实现路由懒加载。 12const Home = () =&gt; import(&#x27;./views/Home.vue&#x27;);const About = () =&gt; import(&#x27;./views/About.vue&#x27;); 这里的import语句会将路由组件按需加载，只有在用户访问相关路由时才加载相应的组件。 7.2 使用Webpack的require.ensure在较早的Vue.js版本中，你可以使用Webpack的require.ensure来实现路由懒加载。不过，现代Vue.js项目通常更推荐使用动态导入。 12const Home = resolve =&gt; require.ensure([], () =&gt; resolve(require(&#x27;./views/Home.vue&#x27;)));const About = resolve =&gt; require.ensure([], () =&gt; resolve(require(&#x27;./views/About.vue&#x27;))); 无论你选择哪种方法，路由懒加载的效果是一样的，即在用户访问相关路由时才加载相应的路由组件。这可以显著减小初始加载的包大小，提高应用的性能。确保你的应用使用现代构建工具（如Webpack）以及Vue Router的支持，以便轻松实现路由懒加载。 8. 导航守卫当使用 Vue Router 来管理路由的时候，导航守卫允许你在路由切换的不同阶段执行特定操作。下面将更详细地介绍导航守卫的使用和用途： 8.1 全局前置守卫 (beforeEach)： 全局前置守卫是在路由切换前执行的，通常用于进行身份验证和权限检查。 你可以在 router 对象上使用 beforeEach 钩子，以全局方式应用于所有路由。 1234567router.beforeEach((to, from, next) =&gt; &#123; if (to.meta.requiresAuth &amp;&amp; !userIsAuthenticated) &#123; next(&#x27;/login&#x27;); // 重定向到登录页 &#125; else &#123; next(); // 允许继续导航 &#125;&#125;) 8.2 全局解析守卫 (beforeResolve)：** 全局解析守卫在导航成功被确认之前执行，常用于等待异步操作的完成。 beforeResolve 钩子在全局前置守卫之后、路由组件渲染之前执行。 1234router.beforeResolve((to, from, next) =&gt; &#123; // 在导航成功前执行一些操作 next();&#125;) 8.3 全局后置守卫 (afterEach)： 全局后置守卫在路由导航完成后执行，通常用于执行一些全局操作，如日志记录或分析。 1234javascriptCopy coderouter.afterEach((to, from) =&gt; &#123; // 在路由导航完成后执行操作&#125;) 8.4 路由独享的守卫： 你可以在路由配置中设置 beforeEnter 来指定只在特定路由上执行的守卫。 1234567891011const adminRoute = &#123; path: &#x27;/admin&#x27;, component: AdminComponent, beforeEnter: (to, from, next) =&gt; &#123; if (userIsAdmin) &#123; next(); &#125; else &#123; next(&#x27;/access-denied&#x27;); // 重定向到拒绝访问页 &#125; &#125;&#125; 8.5 组件内的守卫 (beforeRouteEnter, beforeRouteUpdate, beforeRouteLeave)：** 组件内的守卫允许你在组件生命周期中定义特定的路由导航逻辑。 beforeRouteEnter 在路由进入组件前执行，但此时组件实例还未被创建。 beforeRouteUpdate 在路由参数变化时执行。 beforeRouteLeave 在组件离开前执行。 1234567891011const MyComponent = &#123; beforeRouteEnter(to, from, next) &#123; // 在组件进入前执行，但组件实例还未创建 &#125;, beforeRouteUpdate(to, from, next) &#123; // 路由参数变化时执行 &#125;, beforeRouteLeave(to, from, next) &#123; // 在组件离开前执行 &#125;&#125; 导航守卫是非常有用的工具，用于控制路由的行为，实现身份验证、权限控制和其他路由导航逻辑。你可以根据应用程序的需求，在不同阶段执行特定的操作来实现自定义的路由控制逻辑。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Vue-resource","slug":"8. Vue-resource","date":"2023-10-30T16:00:00.000Z","updated":"2023-10-31T06:01:18.282Z","comments":true,"path":"2023/10/31/8. Vue-resource/","link":"","permalink":"http://example.com/2023/10/31/8.%20Vue-resource/","excerpt":"","text":"1. 简介vue-resource 是 Vue.js 官方推出的 HTTP 请求库，用于发起 AJAX 请求、处理响应和与后端API进行通信。然而，自 Vue.js 2.0 版本起，&#x3D;&#x3D;Vue 官方推荐使用 axios 或 Fetch API 来代替 vue-resource，因此 vue-resource 已经不再维护，新项目应该尽量避免使用它。&#x3D;&#x3D; 2. 示例 首先，确保你已经在项目中安装了 vue-resource，你可以使用 npm 或 yarn 安装它： 1npm install vue-resource 在你的Vue项目中，你需要将 vue-resource 引入并注册为Vue插件。这通常在入口文件（例如 main.js）中完成： 123456import Vue from &#x27;vue&#x27;;import VueResource from &#x27;vue-resource&#x27;;Vue.use(VueResource);// 接下来，你可以在Vue组件中使用VueResource 现在你可以在Vue组件中使用 this.$http 发起HTTP请求，例如： 123456789this.$http.get(&#x27;/api/data&#x27;) .then(response =&gt; &#123; // 处理成功的响应 console.log(response.body); &#125;) .catch(error =&gt; &#123; // 处理错误 console.error(error); &#125;); vue-resource 提供了各种HTTP请求方法，包括 get、post、put、delete 等，以及一些拦截器和请求&#x2F;响应的拦截功能。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"API请求和数据交互","slug":"9. API请求和数据交互","date":"2023-10-30T16:00:00.000Z","updated":"2023-10-31T06:01:14.151Z","comments":true,"path":"2023/10/31/9. API请求和数据交互/","link":"","permalink":"http://example.com/2023/10/31/9.%20API%E8%AF%B7%E6%B1%82%E5%92%8C%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/","excerpt":"","text":"1. AxiosAxios 是一个流行的基于 Promise 的 HTTP 客户端库，用于进行网络请求。它提供了一种简单而强大的方式来执行 HTTP 请求，支持浏览器和Node.js环境。 Axios 提供了丰富的功能，包括处理请求和响应的拦截、取消请求、处理文件上传等。它是一个功能强大而易于使用的工具，适用于多种前端项目，特别是在 Vue.js 项目中进行 API 请求和数据交互。 1.1 安装和引入 Axios12345678//使用npm下载npm install axios//使用yarn下载yarn add axios//在 Vue 组件或 JavaScript 文件中引入 Axios：import axios from &#x27;axios&#x27;; 1.2 发起 GET 请求使用 Axios 发起 GET 请求，以下是一个示例： 123456789axios.get(&#x27;/api/data&#x27;) .then(response =&gt; &#123; // 处理成功的响应 console.log(response.data); &#125;) .catch(error =&gt; &#123; // 处理错误 console.error(error); &#125;); 在上述示例中，axios.get 方法返回一个 Promise，你可以使用 .then() 处理成功的响应，并使用 .catch() 处理错误。 1.3 发起 POST 请求使用 Axios 发起 POST 请求，以下是一个示例： 1234567891011121314const data = &#123; username: &#x27;exampleUser&#x27;, password: &#x27;examplePassword&#x27;&#125;;axios.post(&#x27;/api/login&#x27;, data) .then(response =&gt; &#123; // 处理成功的响应 console.log(response.data); &#125;) .catch(error =&gt; &#123; // 处理错误 console.error(error); &#125;); 在 POST 请求中，你可以提供数据对象，并使用 .post 方法指定请求的 URL。 1.4 Axios 拦截器和全局配置Axios 允许你设置全局的请求拦截器和响应拦截器，以便在请求和响应时执行特定操作。这对于添加身份验证标头、处理响应数据、或执行其他全局操作非常有用。例如： 1234567891011121314151617// 设置请求拦截器axios.interceptors.request.use(config =&gt; &#123; // 在请求发送前可以做一些处理 console.log(&#x27;请求正在发送...&#x27;); return config;&#125;, error =&gt; &#123; return Promise.reject(error);&#125;);// 设置响应拦截器axios.interceptors.response.use(response =&gt; &#123; // 在请求完成后可以对响应进行处理 console.log(&#x27;响应已收到。&#x27;); return response;&#125;, error =&gt; &#123; return Promise.reject(error);&#125;); 2. Fetch APIFetch API 是现代 JavaScript 的内置方法，用于进行网络请求。它是一种原生的、基于 Promise 的方法，用于获取数据和与远程服务器通信。以下是如何使用 Fetch API 发起 GET 请求的示例： 2.1 发起 GET 请求使用 Fetch API 发起 GET 请求，以下是一个示例： 123456789101112131415fetch(&#x27;/api/data&#x27;) .then(response =&gt; &#123; if (!response.ok) &#123; throw new Error(&#x27;网络错误&#x27;); &#125; return response.json(); // 将响应解析为 JSON &#125;) .then(data =&gt; &#123; // 成功处理数据 console.log(data); &#125;) .catch(error =&gt; &#123; // 处理错误 console.error(error); &#125;); 上述示例中，fetch 方法返回一个 Promise，你可以使用 .then() 处理成功的响应，并使用 .catch() 处理错误。 2.2 发起 POST 请求使用 Fetch API 发起 POST 请求，以下是一个示例： 1234567891011121314151617181920212223242526const data = &#123; username: &#x27;exampleUser&#x27;, password: &#x27;examplePassword&#x27;&#125;;fetch(&#x27;/api/login&#x27;, &#123; method: &#x27;POST&#x27;, // 请求方法 headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; // 请求头信息 &#125;, body: JSON.stringify(data) // 请求体数据&#125;) .then(response =&gt; &#123; if (!response.ok) &#123; throw new Error(&#x27;网络错误&#x27;); &#125; return response.json(); &#125;) .then(data =&gt; &#123; // 处理成功的响应 console.log(data); &#125;) .catch(error =&gt; &#123; // 处理错误 console.error(error); &#125;); 在 POST 请求中，你可以提供数据对象，并使用 .fetch 方法指定请求的 URL，请求方法，请求头信息和请求体数据。Fetch API 具有 .json() 方法，用于解析 JSON 响应数据。你也可以使用 .text()、.blob() 等方法来处理其他类型的响应。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Vue工程化开发","slug":"6. Vue工程化开发","date":"2023-10-30T16:00:00.000Z","updated":"2023-10-31T06:01:20.662Z","comments":true,"path":"2023/10/31/6. Vue工程化开发/","link":"","permalink":"http://example.com/2023/10/31/6.%20Vue%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BC%80%E5%8F%91/","excerpt":"","text":"1. Vue安装和项目创建 注：这个过程使用Vue CLI，确保已安装Node.js和npm。 步骤1：安装Vue CLI首先，你需要全局安装Vue CLI。打开终端并运行以下命令： 1npm install -g @vue/cli 步骤2：创建Vue项目Vue CLI将提示你选择一个预设配置或手动配置项目。选择一个预设配置，或使用箭头键和回车键进行手动配置。 1vue create my-vue-app 步骤3：项目配置如果你选择手动配置，你将需要配置一些选项，例如Babel、ESLint、预处理器等。根据你的项目需求进行选择，或使用默认配置。Vue CLI将显示一系列可配置的特性。使用箭头键和回车键来选择和配置这些特性，例如： Babel：用于将ES6+语法编译成浏览器可识别的JavaScript。 TypeScript：如果你想在项目中使用TypeScript。 ESLint：用于代码规范检查。 Unit Testing：如果你希望添加单元测试。 E2E Testing：如果你希望添加端到端测试。 Router：用于Vue Router的支持。 Vuex：用于状态管理的支持。 等等… 步骤4：依赖安装1npm install 步骤5：启动服务器 进入项目目录： 1cd my-vue-app 启动开发服务器： 1npm run serve 开发服务器将运行，并你将看到一个本地服务器地址（通常是http://localhost:8080/）。在浏览器中打开此地址以查看你的Vue应用。 步骤6：开发项目现在你可以开始开发项目。Vue CLI已为你生成一个基本的Vue.js应用，你可以在src/目录中找到主要的应用代码。 步骤7：构建项目当项目完成时，你可以使用以下命令来构建生产版本的项目：这将生成一个dist目录，其中包含用于生产部署的优化文件。 1npm run build 步骤8：部署项目将dist目录中的文件部署到Web服务器或静态文件托管服务上，以使你的Vue应用在生产环境中运行。 2. Vue项目架构Vue.js项目通常遵循一种标准的项目结构，以确保项目的组织、可维护性和可扩展性。以下是一个常见的Vue项目结构示例： 12345678910111213141516171819202122232425my-vue-app/|-- public/| |-- index.html # 应用入口HTML文件| |-- favicon.ico # 网站图标|-- src/| |-- assets/ # 静态资源文件，如图片、样式表| |-- components/ # 可复用的Vue组件| |-- views/ # 页面级别的Vue组件| |-- router/ # Vue Router配置文件| |-- store/ # Vuex状态管理文件| |-- api/ # API请求封装| |-- utils/ # 工具函数、辅助类| |-- mixins/ # 全局混入| |-- directives/ # 自定义指令| |-- filters/ # 过滤器| |-- plugins/ # 第三方插件或库| |-- styles/ # 全局样式文件| |-- main.js # 应用入口JavaScript文件| |-- App.vue # 应用的主组件|-- tests/ # 测试文件|-- package.json # 项目依赖和配置|-- babel.config.js # Babel配置文件|-- vue.config.js # Vue CLI配置文件|-- .eslintrc.js # ESLint配置文件|-- README.md # 项目文档 **public&#x2F;**：这个目录包含不需要经过构建处理的静态资源文件，如index.html、网站图标等。 **src&#x2F;**：这是主要的项目源代码目录，包括组件、视图、路由、状态管理等。具体如下： **assets&#x2F;**：用于存放项目的静态资源文件，如图片、样式表等。 **components&#x2F;**：包含可复用的Vue组件，可以在不同页面中使用。 **views&#x2F;**：页面级别的Vue组件，通常与路由相关。 **router&#x2F;**：Vue Router的配置文件，用于设置路由规则。 **store&#x2F;**：Vuex状态管理文件，用于全局状态管理。 main.js：应用的入口JavaScript文件，初始化Vue应用并配置Vue插件等。 App.vue： 文件通常包含了应用的整体结构、布局和样式，同时也可以包含一些全局的组件和逻辑。这个文件在项目的入口处被引入并渲染，因此是整个Vue应用的主要入口点。 **tests&#x2F;**：包含测试文件和配置，用于单元测试和端到端测试。 node_modules&#x2F;：这是项目依赖的第三方库的存储位置，通常由npm或Yarn管理。 package-lock.json：这个文件用于锁定项目依赖库的版本，确保项目在不同环境中拥有相同的依赖版本。 package.json：项目依赖和配置文件，包含项目所需的依赖库、脚本命令等。 babel.config.js：Babel的配置文件，用于编译JavaScript代码。 vue.config.js：Vue CLI的配置文件，用于自定义Vue应用的构建和开发环境配置。 .eslintrc.js：ESLint的配置文件，用于代码规范检查和静态分析。 README.md：项目文档，包含项目的简介、安装、运行指南等信息。 3. Vue脚手架（vue-cli）","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"","slug":"4. Vue特性","date":"2023-10-19T01:04:28.828Z","updated":"2023-10-19T01:04:44.000Z","comments":true,"path":"2023/10/19/4. Vue特性/","link":"","permalink":"http://example.com/2023/10/19/4.%20Vue%E7%89%B9%E6%80%A7/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Vue简介","slug":"Vue简介","date":"2023-10-11T23:56:22.000Z","updated":"2023-10-13T02:13:12.242Z","comments":true,"path":"2023/10/12/Vue简介/","link":"","permalink":"http://example.com/2023/10/12/Vue%E7%AE%80%E4%BB%8B/","excerpt":"","text":"一、基本概念 声明式渲染：只告诉程序想要什么结果，如何达成由程序保证，开发者不用关心。不用操作DOM，直接更新数据声明式渲染好处：比如在vue中，只需定义好展示数据，并把它放在 template中 合适的位置。 命令式渲染：一步一步告诉程序怎么做，能否达成结果取决于开发者的设计。而命令式渲染，如果 DOM 发生变化，js 代码也需要做相应的改变，耦合度很强。而重绘非常耗费性能。JS操作Dom，常常频繁地触发重绘。但是如果把更新 DOM 的操作交给 Vue、React 去做，让 Virtual DOM 发挥作用，可有效提高页面性能。","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"git常用指令","slug":"git常用指令","date":"2023-07-24T16:00:00.000Z","updated":"2023-07-25T07:58:30.770Z","comments":true,"path":"2023/07/25/git常用指令/","link":"","permalink":"http://example.com/2023/07/25/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"","text":"一、基本操作指令git init：初始化一个新的Git仓库。 git add &lt;filename&gt;：将文件添加到Git索引中。 git commit -m &quot;Commit message&quot;：提交更改，并附上提交消息。 git status：查看当前Git仓库的状态。 二、分支管理指令git branch：列出所有分支。 git branch &lt;branchname&gt;：创建一个新的分支。 git branch -d &lt;branchname&gt;：删除指定的分支。 git branch -a：列出本地和远程所有分支。 git branch -m &lt;oldbranchname&gt; &lt;newbranchname&gt;：将指定的分支重命名。 git checkout &lt;branchname&gt;：切换到指定的分支。 git checkout -b &lt;branchname&gt;：创建一个新的分支，并切换到该分支。 git merge &lt;branchname&gt;：将指定分支合并到当前分支。 git push &lt;remote&gt; &lt;branch&gt;：将本地分支推送到远程分支。 git push &lt;remote&gt; :&lt;branchname&gt;：删除远程分支。 git pull &lt;remote&gt; &lt;branch&gt;：从远程分支拉取代码并合并到当前分支。 三、远程仓库指令git clone &lt;repository&gt;：从远程仓库克隆整个代码库到本地。 git remote add &lt;name&gt; &lt;url&gt;：将本地代码库与远程仓库进行关联。 git remote -v：显示所有已经与本地仓库关联的远程仓库信息。 git fetch &lt;remote&gt;：从远程仓库拉取最新的代码到本地，但不会自动合并。 git pull &lt;remote&gt; &lt;branch&gt;：从远程仓库拉取最新的代码到本地，并自动合并到当前分支。 git push &lt;remote&gt; &lt;branch&gt;：将本地的代码推送到远程仓库指定分支。 git remote show &lt;remote&gt;：显示指定远程仓库的详细信息，包括分支和标签等。 git remote rename &lt;oldname&gt; &lt;newname&gt;：将已经存在的远程仓库别名进行重命名。 git remote remove &lt;name&gt;：删除指定名称的远程仓库关联。 四、撤销操作指令在Git中，撤销操作包括撤销已提交的修改、撤销已经暂存的修改和取消已经执行的Git命令等。以下是一些常用的Git撤销操作指令： git checkout &lt;file&gt;：将指定文件恢复到上一次提交的状态，也可以使用 git checkout . 恢复所有文件。git reset &lt;file&gt;：将指定文件恢复到上一次未暂存的状态，也可以使用 git reset 恢复所有文件。git reset HEAD &lt;file&gt;：将指定文件从已暂存的状态中恢复到未暂存的状态。git revert &lt;commit&gt;：撤销指定的提交，生成一个新的提交以恢复先前的状态。git stash：将当前的修改暂存起来，以便稍后恢复。git stash pop：将最近一次暂存的修改还原回来，并将暂存的修改从堆栈中移除。git cherry-pick &lt;commit&gt;：将指定的提交合并到当前分支中。git commit --amend：修改上一次提交的信息 五、查看日志指令git log：查看Git仓库的提交历史。 git diff：查看文件的变更记录。 git log --graph：查看分支历史记录的图形表示。 六、其他操作指令.gitignore：忽略不需要跟踪的文件。 git tag &lt;tagname&gt;：创建一个新的标签。 git stash：将未提交的更改保存到一个临时的存储区，以便稍后恢复。","categories":[{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git基础教程","slug":"git基础教程","date":"2023-07-24T16:00:00.000Z","updated":"2023-10-13T02:19:23.260Z","comments":true,"path":"2023/07/25/git基础教程/","link":"","permalink":"http://example.com/2023/07/25/git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/","excerpt":"","text":"一、安装 Git首先，您需要安装 Git。您可以从官方网站https://git-scm.com/downloads 下载安装程序，然后按照安装向导完成安装过程。 初始化仓库 要开始使用 Git，您需要在您的计算机上创建一个 Git 仓库。要初始化一个新的 Git 仓库，请在命令行中导航到您的项目目录并运行以下命令： 1git init 这将在当前目录下创建一个新的 Git 仓库。 二、添加和提交文件一旦您的 Git 仓库被初始化，您可以将文件添加到 Git 中。要添加文件，请运行以下命令： 1git add &lt;filename&gt; 要提交添加的文件，请运行以下命令： 1git commit -m &quot;message&quot; 在提交时，您需要提供提交消息，以便其他开发人员了解您所做的更改。 三、查看历史记录要查看 Git 仓库的历史记录，请运行以下命令： 1git log 这将显示所有提交的历史记录，包括每个提交的作者，提交日期和提交消息。 四、分支管理Git 还允许您创建和管理分支。分支是一个从主分支派生的副本，您可以在其中进行修改，而不会影响主分支。要创建分支，请运行以下命令： 1git branch &lt;branchname&gt; 要切换到新分支，请运行以下命令： 1git checkout &lt;branchname&gt; 在您完成对分支的更改后，您可以将其合并回主分支。要将分支合并到主分支，请运行以下命令： 1git merge &lt;branchname&gt; 这将把您对分支所做的更改合并到主分支中。 五、远程仓库最后，您可能需要将 Git 仓库与远程仓库（如 GitHub）同步。要将您的本地仓库上传到远程仓库，请运行以下命令： 12git remote add origin &lt;remote repository URL&gt;git push origin master 这将把您的本地仓库与远程仓库同步，并将您的更改上传到远程仓库中。","categories":[{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"git概述","slug":"git概述","date":"2023-07-24T16:00:00.000Z","updated":"2023-07-25T07:53:42.096Z","comments":true,"path":"2023/07/25/git概述/","link":"","permalink":"http://example.com/2023/07/25/git%E6%A6%82%E8%BF%B0/","excerpt":"","text":"一、四个工作区域在Git中，有四个不同的工作区域，分别是工作区（Working Directory）、暂存区（Index）、本地仓库（Local Repository）和远程仓库（Remote Repository）。 工作区（Working Directory）：指项目所在的目录，也就是用户直接进行文件修改和操作的地方。在工作区中可以进行任意修改、添加、删除等操作，但这些修改不会被记录到Git仓库中。 暂存区（Index）：暂存区是Git仓库中的一个虚拟区域，用于暂存将要提交的修改。通过 git add 命令将工作区中的修改添加到暂存区中，表示这些修改已经准备好被提交了。暂存区的目的是为了提供更加灵活的提交方式，允许用户将修改分成多个提交，以便更好地管理和控制项目的版本。 本地仓库（Local Repository）：本地仓库是存储着项目历史记录的数据库，包括了所有版本的提交和分支等信息。每个本地仓库都包含一个 .git 目录，该目录包含了所有的Git元数据，如对象库、分支、标签等信息。 远程仓库（Remote Repository）：远程仓库是存储着项目的一个备份，通常位于网络上的其他计算机或服务器上。远程仓库可以通过 git clone 命令进行克隆，或者通过 git remote 命令进行连接和管理。远程仓库允许多人协作开发同一个项目，通过推送（push）和拉取（pull）操作，可以在本地仓库和远程仓库之间进行同步。 这四个工作区域在Git中扮演着不同的角色和功能，通过它们的配合，可以实现对项目的版本控制、协作开发和代码管理等功能。 二、五种状态在Git中，一个文件可以处于以下5种状态之一： 未跟踪（Untracked）：文件没有被Git追踪，即没有在Git的版本控制下。 已修改（Modified）：文件已经被修改，但还没有被添加到Git的暂存区。 已暂存（Staged）：文件已经被添加到Git的暂存区，等待被提交到Git仓库中。 已提交（Committed）：文件已经被提交到Git仓库中，即已经保存到Git的历史记录中。 已忽略（Ignored）：文件被添加到了.gitignore文件中，Git会忽略这些文件，不会被追踪或提交到Git仓库中。 通过 git status 命令可以查看当前工作目录下文件的状态，以及跟踪和未跟踪的文件列表。根据文件的状态，可以使用不同的Git命令进行相应的操作，如 git add 将文件添加到暂存区，git commit 将文件提交到仓库中，git rm 删除文件等。","categories":[{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"AOP","slug":"AOP","date":"2023-07-24T16:00:00.000Z","updated":"2023-10-13T02:16:06.474Z","comments":true,"path":"2023/07/25/AOP/","link":"","permalink":"http://example.com/2023/07/25/AOP/","excerpt":"","text":"一、什么是AOP AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 二、核心概念1. 横切关注点对哪些方法进行拦截,拦截后怎么处理，这些关注点称之为横切关注点 2. 切面（aspect）（自定义Log类）将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。例如打印日志。 3. 连接点（joinpoint）被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器 4. 切入点（pointcut）（需要打印Log的类）对连接点进行拦截的定义 5. 通知（advice）（Log类中的具体方法）所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类 6. 目标对象代理的目标对象 7. 织入（weave）将切面应用到目标对象并导致代理对象创建的过程 8. 引入（introduction）在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段 三、具体实现1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.3.6&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 四、配置切面、切入点、通知1. 通过spring.xml配置12345678public class TimeLog &#123; public void printLogBefore()&#123; System.out.println(&quot;====Before====&quot;); &#125; public void printLogAfter()&#123; System.out.println(&quot;=====After=====&quot;); &#125;&#125; 12345678910111213&lt;bean id=&quot;timeLog&quot; class=&quot;log.TimeLog&quot;/&gt;&lt;aop:config&gt; &lt;!--定义切面为TimeLog--&gt; &lt;aop:aspect ref=&quot;timeLog&quot;&gt; &lt;!--定义切入点为UserServiceImpl中的所有方法--&gt; &lt;aop:pointcut id=&quot;pointcut1&quot; expression=&quot;execution(* service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--定义前置通知为TimeLog.printLogBefore()方法--&gt; &lt;aop:before method=&quot;printLogBefore&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;!--定义后置通知为TimeLog.printLogAfter()方法--&gt; &lt;aop:after method=&quot;printLogAfter&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 2. 通过注解将类定义为切面123456789101112131415161718//方式2import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class AnnotationLog &#123; @Before(value = &quot;execution(* service.UserServiceImpl.*(..))&quot;) public void beforeLog()&#123; System.out.println(&quot;beforeLog&quot;); &#125; @After(value = &quot;execution(* service.UserServiceImpl.*(..))&quot;) public void afterLog()&#123; System.out.println(&quot;afterLog&quot;); &#125;&#125; 3. 通过实现接口定义通知的类型 + xml配置123456789import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;public class PreLog implements MethodBeforeAdvice &#123; @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(&quot;这是log：&quot;+method.getName()); &#125;&#125; 1234567&lt;bean id=&quot;preLog&quot; class=&quot;log.PreLog&quot;/&gt;&lt;aop:config&gt; &lt;!--切入点：要执行log的地方--&gt; &lt;aop:pointcut id=&quot;pre&quot; expression=&quot;execution(* service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行什么方法--&gt; &lt;aop:advisor advice-ref=&quot;preLog&quot; pointcut-ref=&quot;pre&quot;/&gt;&lt;/aop:config&gt;","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/categories/SpringMVC/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"http://example.com/tags/AOP/"}]},{"title":"Vue简介","slug":"1. Vue简介","date":"2023-07-24T16:00:00.000Z","updated":"2023-10-31T06:01:26.499Z","comments":true,"path":"2023/07/25/1. Vue简介/","link":"","permalink":"http://example.com/2023/07/25/1.%20Vue%E7%AE%80%E4%BB%8B/","excerpt":"","text":"学习大纲 1. 什么是Vue？ Vue (发音为 &#x2F;vjuː&#x2F;，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。 2. Vue特点 javaScript框架 声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。 响应性：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM。 3. API风格Vue 的组件可以按两种不同的风格书写：选项式 API 和组合式 API。 3.1 选项式API 使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。选项所定义的属性都会暴露在函数内部的 this 上，它会指向当前的组件实例。 1234567891011121314151617181920212223242526272829&lt;script&gt;export default &#123; // data() 返回的属性将会成为响应式的状态 // 并且暴露在 `this` 上 data() &#123; return &#123; count: 0 &#125; &#125;, // methods 是一些用来更改状态与触发更新的函数 // 它们可以在模板中作为事件处理器绑定 methods: &#123; increment() &#123; this.count++ &#125; &#125;, // 生命周期钩子会在组件生命周期的各个不同阶段被调用 // 例如这个函数就会在组件挂载完成后被调用 mounted() &#123; console.log(`The initial count is $&#123;this.count&#125;.`) &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt; 3.2 组合式API 通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与**script setup** 搭配使用。这个 setup attribute 是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，**&lt;script setup&gt;** 中的导入和顶层变量&#x2F;函数都能够在模板中直接使用。 1234567891011121314151617181920&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;// 响应式状态const count = ref(0)// 用来修改状态、触发更新的函数function increment() &#123; count.value++&#125;// 生命周期钩子onMounted(() =&gt; &#123; console.log(`The initial count is $&#123;count.value&#125;.`)&#125;)&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/categories/Vue/"},{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"工作","slug":"工作","permalink":"http://example.com/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/categories/SpringMVC/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"http://example.com/tags/AOP/"}]}