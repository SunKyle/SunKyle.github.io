<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/10/12/Vue%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/10/12/Vue%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue简介"><a href="#Vue简介" class="headerlink" title="Vue简介"></a>Vue简介</h1><p>一、基本概念</p><blockquote><p>声明式渲染：只告诉程序想要什么结果，如何达成由程序保证，开发者不用关心。不用操作DOM，直接更新数据</p></blockquote><p>命令式渲染：一步一步告诉程序怎么做，能否达成结果取决于开发者的设计。</p><p>声明式渲染好处：<br>比如在vue中，只需定义好展示数据，并把它放在 template中 合适的位置。</p><p>而命令式渲染，如果 DOM 发生变化，js 代码也需要做相应的改变，耦合度很强。<br>而重绘非常耗费性能。JS操作Dom，常常频繁地触发重绘。但是如果把更新 DOM 的操作交给 Vue、React 去做，让 Virtual DOM 发挥作用，可有效提高页面性能。</p><p><img src="/Vue%E7%AE%80%E4%BB%8B%20788e01d5ab5b48afbc2ee3d169eae86e/Untitled.png" alt="Untitled"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git常用指令</title>
      <link href="/2023/07/25/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/07/25/git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本操作指令"><a href="#一、基本操作指令" class="headerlink" title="一、基本操作指令"></a>一、<strong>基本操作指令</strong></h2><p><code>git init</code>：初始化一个新的Git仓库。</p><p><code>git add &lt;filename&gt;</code>：将文件添加到Git索引中。</p><p><code>git commit -m &quot;Commit message&quot;</code>：提交更改，并附上提交消息。</p><p><code>git status</code>：查看当前Git仓库的状态。</p><h2 id="二、分支管理指令"><a href="#二、分支管理指令" class="headerlink" title="二、分支管理指令"></a>二、<strong>分支管理指令</strong></h2><p><code>git branch</code>：列出所有分支。</p><p><code>git branch &lt;branchname&gt;</code>：创建一个新的分支。</p><p><code>git branch -d &lt;branchname&gt;</code>：删除指定的分支。</p><p><code>git branch -a</code>：列出本地和远程所有分支。</p><p><code>git branch -m &lt;oldbranchname&gt; &lt;newbranchname&gt;</code>：将指定的分支重命名。</p><p><code>git checkout &lt;branchname&gt;</code>：切换到指定的分支。</p><p><code>git checkout -b &lt;branchname&gt;</code>：创建一个新的分支，并切换到该分支。</p><p><code>git merge &lt;branchname&gt;</code>：将指定分支合并到当前分支。</p><p><code>git push &lt;remote&gt; &lt;branch&gt;</code>：将本地分支推送到远程分支。</p><p><code>git push &lt;remote&gt; :&lt;branchname&gt;</code>：删除远程分支。</p><p><code>git pull &lt;remote&gt; &lt;branch&gt;</code>：从远程分支拉取代码并合并到当前分支。</p><h2 id="三、远程仓库指令"><a href="#三、远程仓库指令" class="headerlink" title="三、远程仓库指令"></a>三、<strong>远程仓库指令</strong></h2><p><code>git clone &lt;repository&gt;</code>：从远程仓库克隆整个代码库到本地。</p><p><code>git remote add &lt;name&gt; &lt;url&gt;</code>：将本地代码库与远程仓库进行关联。</p><p><code>git remote -v</code>：显示所有已经与本地仓库关联的远程仓库信息。</p><p><code>git fetch &lt;remote&gt;</code>：从远程仓库拉取最新的代码到本地，但不会自动合并。</p><p><code>git pull &lt;remote&gt; &lt;branch&gt;</code>：从远程仓库拉取最新的代码到本地，并自动合并到当前分支。</p><p><code>git push &lt;remote&gt; &lt;branch&gt;</code>：将本地的代码推送到远程仓库指定分支。</p><p><code>git remote show &lt;remote&gt;</code>：显示指定远程仓库的详细信息，包括分支和标签等。</p><p><code>git remote rename &lt;oldname&gt; &lt;newname&gt;</code>：将已经存在的远程仓库别名进行重命名。</p><p><code>git remote remove &lt;name&gt;</code>：删除指定名称的远程仓库关联。</p><h2 id="四、撤销操作指令"><a href="#四、撤销操作指令" class="headerlink" title="四、撤销操作指令"></a>四、<strong>撤销操作指令</strong></h2><p>在Git中，撤销操作包括撤销已提交的修改、撤销已经暂存的修改和取消已经执行的Git命令等。以下是一些常用的Git撤销操作指令：</p><p><code>git checkout &lt;file&gt;</code>：将指定文件恢复到上一次提交的状态，也可以使用 <code>git checkout .</code> 恢复所有文件。<br><code>git reset &lt;file&gt;</code>：将指定文件恢复到上一次未暂存的状态，也可以使用 <code>git reset</code> 恢复所有文件。<br><code>git reset HEAD &lt;file&gt;</code>：将指定文件从已暂存的状态中恢复到未暂存的状态。<br><code>git revert &lt;commit&gt;</code>：撤销指定的提交，生成一个新的提交以恢复先前的状态。<br><code>git stash</code>：将当前的修改暂存起来，以便稍后恢复。<br><code>git stash pop</code>：将最近一次暂存的修改还原回来，并将暂存的修改从堆栈中移除。<br><code>git cherry-pick &lt;commit&gt;</code>：将指定的提交合并到当前分支中。<br><code>git commit --amend</code>：修改上一次提交的信息</p><h2 id="五、查看日志指令"><a href="#五、查看日志指令" class="headerlink" title="五、查看日志指令"></a>五、<strong>查看日志指令</strong></h2><p><code>git log</code>：查看Git仓库的提交历史。</p><p><code>git diff</code>：查看文件的变更记录。</p><p><code>git log --graph</code>：查看分支历史记录的图形表示。</p><h2 id="六、其他操作指令"><a href="#六、其他操作指令" class="headerlink" title="六、其他操作指令"></a>六、<strong>其他操作指令</strong></h2><p><code>.gitignore</code>：忽略不需要跟踪的文件。</p><p><code>git tag &lt;tagname&gt;</code>：创建一个新的标签。</p><p><code>git stash</code>：将未提交的更改保存到一个临时的存储区，以便稍后恢复。</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基础教程</title>
      <link href="/2023/07/25/git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2023/07/25/git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装Git"><a href="#一、安装Git" class="headerlink" title="一、安装Git"></a>一、<strong>安装Git</strong></h2><p>首先，您需要安装Git。您可以从官方网站<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> 下载安装程序，然后按照安装向导完成安装过程。</p><p><strong>初始化仓库</strong></p><p>要开始使用Git，您需要在您的计算机上创建一个Git仓库。要初始化一个新的Git仓库，请在命令行中导航到您的项目目录并运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>这将在当前目录下创建一个新的Git仓库。</p><h2 id="二、添加和提交文件"><a href="#二、添加和提交文件" class="headerlink" title="二、添加和提交文件"></a>二、<strong>添加和提交文件</strong></h2><p>一旦您的Git仓库被初始化，您可以将文件添加到Git中。要添加文件，请运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>要提交添加的文件，请运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure><p>在提交时，您需要提供提交消息，以便其他开发人员了解您所做的更改。</p><h2 id="三、查看历史记录"><a href="#三、查看历史记录" class="headerlink" title="三、查看历史记录"></a>三、<strong>查看历史记录</strong></h2><p>要查看Git仓库的历史记录，请运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>这将显示所有提交的历史记录，包括每个提交的作者，提交日期和提交消息。</p><h2 id="四、分支管理"><a href="#四、分支管理" class="headerlink" title="四、分支管理"></a>四、<strong>分支管理</strong></h2><p>Git还允许您创建和管理分支。分支是一个从主分支派生的副本，您可以在其中进行修改，而不会影响主分支。要创建分支，请运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branchname&gt;</span><br></pre></td></tr></table></figure><p>要切换到新分支，请运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branchname&gt;</span><br></pre></td></tr></table></figure><p>在您完成对分支的更改后，您可以将其合并回主分支。要将分支合并到主分支，请运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branchname&gt;</span><br></pre></td></tr></table></figure><p>这将把您对分支所做的更改合并到主分支中。</p><h2 id="五、远程仓库"><a href="#五、远程仓库" class="headerlink" title="五、远程仓库"></a>五、<strong>远程仓库</strong></h2><p>最后，您可能需要将Git仓库与远程仓库（如GitHub）同步。要将您的本地仓库上传到远程仓库，请运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;remote repository URL&gt; </span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>这将把您的本地仓库与远程仓库同步，并将您的更改上传到远程仓库中。</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git概述</title>
      <link href="/2023/07/25/git%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/07/25/git%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、四个工作区域"><a href="#一、四个工作区域" class="headerlink" title="一、四个工作区域"></a>一、<strong>四个工作区域</strong></h2><p>在Git中，有四个不同的工作区域，分别是工作区（Working Directory）、暂存区（Index）、本地仓库（Local Repository）和远程仓库（Remote Repository）。</p><p><strong>工作区（Working Directory</strong>）：指项目所在的目录，也就是用户直接进行文件修改和操作的地方。在工作区中可以进行任意修改、添加、删除等操作，但这些修改不会被记录到Git仓库中。</p><p><strong>暂存区（Index）</strong>：暂存区是Git仓库中的一个虚拟区域，用于暂存将要提交的修改。通过 <code>git add</code> 命令将工作区中的修改添加到暂存区中，表示这些修改已经准备好被提交了。暂存区的目的是为了提供更加灵活的提交方式，允许用户将修改分成多个提交，以便更好地管理和控制项目的版本。</p><p><strong>本地仓库（Local Repository）</strong>：本地仓库是存储着项目历史记录的数据库，包括了所有版本的提交和分支等信息。每个本地仓库都包含一个 <code>.git</code> 目录，该目录包含了所有的Git元数据，如对象库、分支、标签等信息。</p><p><strong>远程仓库（Remote Repository）</strong>：远程仓库是存储着项目的一个备份，通常位于网络上的其他计算机或服务器上。远程仓库可以通过 <code>git clone</code> 命令进行克隆，或者通过 <code>git remote</code> 命令进行连接和管理。远程仓库允许多人协作开发同一个项目，通过推送（push）和拉取（pull）操作，可以在本地仓库和远程仓库之间进行同步。</p><p>这四个工作区域在Git中扮演着不同的角色和功能，通过它们的配合，可以实现对项目的版本控制、协作开发和代码管理等功能。</p><p><img src="/../picture/pic2.png" alt="Git的四个工作区域"></p><h2 id="二、五种状态"><a href="#二、五种状态" class="headerlink" title="二、五种状态"></a>二、<strong>五种状态</strong></h2><p>在Git中，一个文件可以处于以下5种状态之一：</p><p>未跟踪（Untracked）：文件没有被Git追踪，即没有在Git的版本控制下。</p><p>已修改（Modified）：文件已经被修改，但还没有被添加到Git的暂存区。</p><p>已暂存（Staged）：文件已经被添加到Git的暂存区，等待被提交到Git仓库中。</p><p>已提交（Committed）：文件已经被提交到Git仓库中，即已经保存到Git的历史记录中。</p><p>已忽略（Ignored）：文件被添加到了.gitignore文件中，Git会忽略这些文件，不会被追踪或提交到Git仓库中。</p><p>通过 <code>git status</code> 命令可以查看当前工作目录下文件的状态，以及跟踪和未跟踪的文件列表。根据文件的状态，可以使用不同的Git命令进行相应的操作，如 <code>git add</code> 将文件添加到暂存区，<code>git commit</code> 将文件提交到仓库中，<code>git rm</code> 删除文件等。</p><p><img src="/../picture/pic1.png" alt="文件的五种状态"></p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP</title>
      <link href="/2023/07/25/AOP/"/>
      <url>/2023/07/25/AOP/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是AOP"><a href="#一、什么是AOP" class="headerlink" title="一、什么是AOP"></a>一、什么是AOP</h2><blockquote><p>AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p></blockquote><blockquote><p>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p></blockquote><blockquote><p>使用”横切”技术，AOP把软件系统分为两个部分：<strong>核心关注点</strong>和<strong>横切关注点</strong>。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p></blockquote><h2 id="二、核心概念"><a href="#二、核心概念" class="headerlink" title="二、核心概念"></a>二、核心概念</h2><h3 id="1-横切关注点"><a href="#1-横切关注点" class="headerlink" title="1. 横切关注点"></a>1. 横切关注点</h3><p><strong>对哪些方法进行拦截，</strong>拦截后怎么处理，这些关注点称之为横切关注点</p><h3 id="2-切面（aspect）"><a href="#2-切面（aspect）" class="headerlink" title="2. 切面（aspect）"></a>2. 切面（aspect）</h3><p>（自定义Log类）将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。例如打印日志。</p><h3 id="3-连接点（joinpoint）"><a href="#3-连接点（joinpoint）" class="headerlink" title="3. 连接点（joinpoint）"></a>3. 连接点（joinpoint）</h3><p>被拦截到的点，因为Spring只支持方法类型的连接点，所以<strong>在Spring中连接点指的就是被拦截到的方法</strong>，实际上连接点还可以是字段或者构造器</p><h3 id="4-切入点（pointcut）"><a href="#4-切入点（pointcut）" class="headerlink" title="4. 切入点（pointcut）"></a>4. 切入点（pointcut）</h3><p>（需要打印Log的类）对连接点进行拦截的定义</p><h3 id="5-通知（advice）"><a href="#5-通知（advice）" class="headerlink" title="5. 通知（advice）"></a>5. 通知（advice）</h3><p>（Log类中的具体方法）所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类</p><h3 id="6-目标对象"><a href="#6-目标对象" class="headerlink" title="6. 目标对象"></a>6. 目标对象</h3><p>代理的目标对象</p><h3 id="7-织入（weave）"><a href="#7-织入（weave）" class="headerlink" title="7. 织入（weave）"></a>7. 织入（weave）</h3><p><strong>将切面应用到目标对象并导致代理对象创建的过程</strong></p><h3 id="8-引入（introduction）"><a href="#8-引入（introduction）" class="headerlink" title="8. 引入（introduction）"></a>8. 引入（introduction）</h3><p>在不修改代码的前提下，引入可以在<strong>运行期</strong>为类动态地添加一些方法或字段</p><h2 id="三、具体实现"><a href="#三、具体实现" class="headerlink" title="三、具体实现"></a>三、具体实现</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、配置切面、切入点、通知"><a href="#四、配置切面、切入点、通知" class="headerlink" title="四、配置切面、切入点、通知"></a>四、配置切面、切入点、通知</h2><h4 id="1-通过spring-xml配置"><a href="#1-通过spring-xml配置" class="headerlink" title="1. 通过spring.xml配置"></a>1. 通过spring.xml配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeLog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBefore</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====Before====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfter</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====After=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;timeLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;log.TimeLog&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义切面为TimeLog--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;timeLog&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--定义切入点为UserServiceImpl中的所有方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--定义前置通知为TimeLog.printLogBefore()方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;printLogBefore&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--定义后置通知为TimeLog.printLogAfter()方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;printLogAfter&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-通过注解将类定义为切面"><a href="#2-通过注解将类定义为切面" class="headerlink" title="2. 通过注解将类定义为切面"></a>2. 通过注解将类定义为切面</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationLog</span>  &#123;</span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeLog</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beforeLog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(value = &quot;execution(* service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterLog</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterLog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-通过实现接口定义通知的类型-xml配置"><a href="#3-通过实现接口定义通知的类型-xml配置" class="headerlink" title="3. 通过实现接口定义通知的类型 + xml配置"></a>3. 通过实现接口定义通知的类型 + xml配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreLog</span> <span class="keyword">implements</span> <span class="title class_">MethodBeforeAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是log：&quot;</span>+method.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;preLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;log.PreLog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切入点：要执行log的地方--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pre&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--执行什么方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;preLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pre&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
